<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spreading Particles</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow-x: hidden;
            background: #000000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .section {
            height: 100vh;
            position: relative;
            z-index: 10;
        }
        
        .solutions-section {
            min-height: 400vh;
            position: relative;
            z-index: 10;
        }
        
        .subsection {
            height: 100vh;
            position: sticky;
            top: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 5%;
            opacity: 0;
            transform: translateY(50px);
            transition: opacity 0.5s ease, transform 0.5s ease;
            width: 100%;
        }
        
        .subsection.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ffffff;
            z-index: 20;
        }
        
        .subsection-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            gap: 2rem;
        }
        
        .text-content {
            flex: 1;
            text-align: left;
            color: #ffffff;
            z-index: 20;
            min-width: 0;
        }
        
        .shape-content {
            flex: 1;
            height: 60vh;
            position: relative;
            transform: translateX(100%);
            transition: transform 0.5s ease;
            z-index: 15;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 0;
        }
        
        .shape-content.visible {
            transform: translateX(0);
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .gradient-text {
            background: linear-gradient(135deg, #ffffff 0%, #cccccc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #ffffff, #cccccc);
            z-index: 100;
            transition: width 0.3s ease;
        }
        
        .solutions-title {
            position: sticky;
            top: 0;
            z-index: 30;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            padding: 2rem 0;
        }
        
        @media (max-width: 768px) {
            .subsection {
                padding: 0 2%;
            }
            
            .subsection-content {
                flex-direction: column;
                gap: 1rem;
            }
            
            .text-content {
                text-align: center;
                width: 100%;
            }
            
            .shape-content {
                width: 100%;
                height: 40vh;
                transform: translateY(100%);
            }
            
            .shape-content.visible {
                transform: translateY(0);
            }
            
            .text-content h2 {
                font-size: 2rem;
            }
            
            .text-content p {
                font-size: 1rem;
            }
        }
        
        @media (max-width: 480px) {
            .subsection {
                padding: 0 1rem;
            }
            
            .text-content h2 {
                font-size: 1.5rem;
            }
            
            .solutions-title h1 {
                font-size: 2.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progress"></div>
    
    <div id="canvas-container"></div>
    
    <div class="section bg-transparent">
        <div class="content">
            <h1 class="text-6xl font-bold mb-6 gradient-text">Automate the mundane</h1>
            <p class="text-xl text-red-600">Elevate The Human Potential</p>
        </div>
    </div>
    
    <div class="solutions-section bg-transparent">
        <div class="solutions-title">
            <h1 class="text-6xl font-bold mb-6 gradient-text text-center">Our Solutions</h1>
        </div>
        
        <div class="subsection" data-shape="ai">
            <div class="subsection-content">
                <div class="text-content">
                    <h2 class="text-4xl font-bold mb-4 gradient-text">Data and AI</h2>
                    <p class="text-lg text-gray-400 leading-relaxed">Harnessing data-driven insights with artificial intelligence to transform your business operations and unlock new possibilities for growth and innovation.</p>
            <br>
                    <button 
                class="relative inline-block px-6 py-3 font-medium group overflow-hidden border bg-black text-white rounded"
            >
            <span class="absolute inset-0 w-0 bg-gray-200 transition-all duration-300 ease-out group-hover:w-full"></span>
            <span class="relative z-10 group-hover:text-black">Learn More</span>
          </button>
                </div>
                <div class="shape-content" data-shape="ai"></div>
            </div>
        </div>
        
        <div class="subsection" data-shape="cloud">
            <div class="subsection-content">
                <div class="text-content">
                    <h2 class="text-4xl font-bold mb-4 gradient-text">Open Hybrid Cloud</h2>
                    <p class="text-lg text-gray-400 leading-relaxed">Seamless integration across hybrid cloud environments, providing flexibility, scalability, and security for your modern infrastructure needs.</p>
                <br>
                    <button 
                class="relative inline-block px-6 py-3 font-medium group overflow-hidden border bg-black text-white rounded"
            >
            <span class="absolute inset-0 w-0 bg-gray-200 transition-all duration-300 ease-out group-hover:w-full"></span>
            <span class="relative z-10 group-hover:text-black">Learn More</span>
          </button>
                </div>
                
                <div class="shape-content" data-shape="cloud"></div>
            </div>
        </div>
        
        <div class="subsection" data-shape="tick">
            <div class="subsection-content">
                <div class="text-content">
                    <h2 class="text-4xl font-bold mb-4 gradient-text">IT and Business Automation</h2>
                    <p class="text-lg text-gray-400 leading-relaxed">Streamlining operations for efficiency and scale, automating repetitive tasks to focus on strategic initiatives that drive business value.</p>
                 <br>
                    <button 
                class="relative inline-block px-6 py-3 font-medium group overflow-hidden border bg-black text-white rounded"
            >
            <span class="absolute inset-0 w-0 bg-gray-200 transition-all duration-300 ease-out group-hover:w-full"></span>
            <span class="relative z-10 group-hover:text-black">Learn More</span>
          </button>
                </div>
                <div class="shape-content" data-shape="tick"></div>
            </div>
        </div>
        
        <div class="subsection" data-shape="key">
            <div class="subsection-content">
                <div class="text-content">
                    <h2 class="text-4xl font-bold mb-4 gradient-text">Security and Sustainability</h2>
                    <p class="text-lg text-gray-400 leading-relaxed">Protecting systems while promoting sustainable practices, ensuring your business is secure, compliant, and environmentally responsible.</p>
                 <br>
                    <button 
                class="relative inline-block px-6 py-3 font-medium group overflow-hidden border bg-black text-white rounded"
            >
            <span class="absolute inset-0 w-0 bg-gray-200 transition-all duration-300 ease-out group-hover:w-full"></span>
            <span class="relative z-10 group-hover:text-black">Learn More</span>
          </button>
                </div>
                <div class="shape-content" data-shape="key"></div>
            </div>
        </div>
    </div>

    <script>
        class SpreadingParticles {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.particleCount = 3000;
                this.currentShape = -1;
                this.targetPositions = new Float32Array(this.particleCount * 3);
                this.originalPositions = new Float32Array(this.particleCount * 3);
                this.morphProgress = 1;
                this.isTransitioning = false;
                this.lastScrollDirection = 1;
                
                this.init();
                this.createParticles();
                this.animate();
                this.setupScrollListener();
            }
            
            init() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setClearColor(0x000000, 0);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                this.camera.position.z = 6;
                
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const pointLight = new THREE.PointLight(0xffffff, 0.8);
                pointLight.position.set(10, 10, 10);
                this.scene.add(pointLight);
                
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            createParticles() {
                const geometry = new THREE.BufferGeometry();
                
                this.generateSpreadPositions(this.originalPositions);
                this.targetPositions.set(this.originalPositions);
                
                geometry.setAttribute('position', new THREE.BufferAttribute(this.originalPositions.slice(), 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.03,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.7,
                    vertexColors: true
                });
                
                const colors = new Float32Array(this.particleCount * 3);
                for (let i = 0; i < this.particleCount; i++) {
                    const color = new THREE.Color(0xffffff);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }
            
            generateSpreadPositions(positions) {
                for (let i = 0; i < this.particleCount; i++) {
                    const x = (Math.random() - 0.5) * 12;
                    const y = (Math.random() - 0.5) * 12;
                    const z = (Math.random() - 0.5) * 12;
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                }
            }
            
            generateAIPositions(positions) {
                let particleIndex = 0;
                const letterSpacing = 1.5;
                const strokeWidth = 0.20;
                
                const aPoints = [
                    ...this.generateLinePoints(-1.5, -1, -0.5, 1, 300),
                    ...this.generateLinePoints(-0.5, 1, 0.5, -1, 300),
                    ...this.generateLinePoints(-1, 0, 0, 0, 200)
                ];
                
                const iPoints = [
                    ...this.generateLinePoints(1.5, -1, 1.5, 1, 400),
                    ...this.generateLinePoints(1.2, 1, 1.8, 1, 100),
                    ...this.generateLinePoints(1.2, -1, 1.8, -1, 100)
                ];
                
                const allPoints = [...aPoints, ...iPoints];
                
                for (let i = 0; i < this.particleCount; i++) {
                    if (i < allPoints.length) {
                        positions[i * 3] = allPoints[i].x;
                        positions[i * 3 + 1] = allPoints[i].y;
                        positions[i * 3 + 2] = allPoints[i].z || 0;
                    } else {
                        positions[i * 3] = (Math.random() - 0.5) * 6;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
                    }
                }
            }
            
            generateLinePoints(x1, y1, x2, y2, count) {
                const points = [];
                for (let i = 0; i < count; i++) {
                    const t = i / count;
                    const x = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 0.1;
                    const y = y1 + (y2 - y1) * t + (Math.random() - 0.5) * 0.1;
                    points.push({ x, y, z: (Math.random() - 0.5) * 0.3 });
                }
                return points;
            }
            
            generateCloudPositions(positions) {
                for (let i = 0; i < this.particleCount; i++) {
                    const cloudCenter = Math.floor(Math.random() * 5);
                    let centerX, centerY, radius;
                    
                    switch(cloudCenter) {
                        case 0:
                            centerX = 0;
                            centerY = 0;
                            radius = 1.2;
                            break;
                        case 1:
                            centerX = -1;
                            centerY = 0.2;
                            radius = 0.8;
                            break;
                        case 2:
                            centerX = 1;
                            centerY = 0.1;
                            radius = 0.9;
                            break;
                        case 3:
                            centerX = -0.3;
                            centerY = 0.8;
                            radius = 0.7;
                            break;
                        case 4:
                            centerX = 0.7;
                            centerY = -0.3;
                            radius = 0.6;
                            break;
                    }
                    
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.random() * radius;
                    
                    positions[i * 3] = centerX + r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = centerY + r * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = r * Math.cos(phi);
                }
            }
            
            generateTickPositions(positions) {
                let particleIndex = 0;
                
                const stroke1Points = this.generateLinePoints(-0.5, 0, 0, -0.8, 600);
                const stroke2Points = this.generateLinePoints(0, -0.8, 1.2, 0.8, 800);
                
                const allPoints = [...stroke1Points, ...stroke2Points];
                
                for (let i = 0; i < this.particleCount; i++) {
                    if (i < allPoints.length) {
                        positions[i * 3] = allPoints[i].x;
                        positions[i * 3 + 1] = allPoints[i].y;
                        positions[i * 3 + 2] = allPoints[i].z || 0;
                    } else {
                        positions[i * 3] = (Math.random() - 0.5) * 4;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 1;
                    }
                }
            }
            
            generateKeyPositions(positions) {
                let particleIndex = 0;
                
                const handlePoints = [];
                for (let i = 0; i < 800; i++) {
                    const angle = (i / 800) * Math.PI * 2;
                    const radius = 0.6;
                    const x = -1.5 + radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    handlePoints.push({ x, y, z: (Math.random() - 0.5) * 0.2 });
                }
                
                const shaftPoints = this.generateLinePoints(-0.9, 0, 1.2, 0, 500);
                
                const teeth1Points = this.generateLinePoints(0.8, 0, 0.8, -0.4, 100);
                const teeth2Points = this.generateLinePoints(1.0, 0, 1.0, -0.3, 100);
                const teeth3Points = this.generateLinePoints(1.2, 0, 1.2, -0.5, 100);
                
                const allPoints = [...handlePoints, ...shaftPoints, ...teeth1Points, ...teeth2Points, ...teeth3Points];
                
                for (let i = 0; i < this.particleCount; i++) {
                    if (i < allPoints.length) {
                        positions[i * 3] = allPoints[i].x;
                        positions[i * 3 + 1] = allPoints[i].y;
                        positions[i * 3 + 2] = allPoints[i].z || 0;
                    } else {
                        positions[i * 3] = (Math.random() - 0.5) * 6;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 1;
                    }
                }
            }
            
            morphToShape(shapeIndex) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                
                const currentPositions = this.particles.geometry.attributes.position.array;
                this.originalPositions.set(currentPositions);
                
                const newPositions = new Float32Array(this.particleCount * 3);
                
                switch(shapeIndex) {
                    case -1:
                        this.generateSpreadPositions(newPositions);
                        break;
                    case 0:
                        this.generateAIPositions(newPositions);
                        break;
                    case 1:
                        this.generateCloudPositions(newPositions);
                        break;
                    case 2:
                        this.generateTickPositions(newPositions);
                        break;
                    case 3:
                        this.generateKeyPositions(newPositions);
                        break;
                }
                
                this.targetPositions.set(newPositions);
                this.morphProgress = 0;
            }
            
            updateMorph() {
                if (this.morphProgress >= 1) {
                    this.isTransitioning = false;
                    return;
                }
                
                const positions = this.particles.geometry.attributes.position.array;
                
                for (let i = 0; i < this.particleCount * 3; i++) {
                    const start = this.originalPositions[i];
                    const target = this.targetPositions[i];
                    const progress = this.easeInOutQuad(this.morphProgress);
                    positions[i] = start + (target - start) * progress;
                }
                
                this.particles.geometry.attributes.position.needsUpdate = true;
                this.morphProgress += 0.02;
            }
            
            easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }
            
            setupScrollListener() {
                let ticking = false;
                let lastScrollTop = 0;
                
                const updateOnScroll = () => {
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
                    const scrollProgress = scrollTop / scrollHeight;
                    
                    document.getElementById('progress').style.width = (scrollProgress * 100) + '%';
                    
                    const sectionHeight = window.innerHeight;
                    const solutionsSection = document.querySelector('.solutions-section');
                    const solutionsTop = solutionsSection.offsetTop;
                    const subsections = document.querySelectorAll('.subsection');
                    
                    this.lastScrollDirection = scrollTop > lastScrollTop ? 1 : -1;
                    lastScrollTop = scrollTop;
                    
                    let shapeIndex = -1;
                    
                    if (scrollTop < sectionHeight) {
                        shapeIndex = -1;
                        this.particles.position.x = 0;
                        this.particles.position.y = 0;
                        subsections.forEach(s => s.classList.remove('visible'));
                        document.querySelectorAll('.shape-content').forEach(s => s.classList.remove('visible'));
                    } else if (scrollTop >= solutionsTop) {
                        const scrollInSolutions = scrollTop - solutionsTop;
                        const subsectionIndex = Math.min(
                            Math.floor(scrollInSolutions / (sectionHeight * 0.8)),
                            subsections.length - 1
                        );
                        shapeIndex = subsectionIndex;
                        
                        subsections.forEach((subsection, index) => {
                            const isVisible = index === subsectionIndex;
                            subsection.classList.toggle('visible', isVisible);
                            const shapeEl = subsection.querySelector('.shape-content');
                            if (shapeEl) {
                                shapeEl.classList.toggle('visible', isVisible);
                            }
                        });
                        
                        // Responsive particle positioning
                        if (window.innerWidth <= 768) {
                            this.particles.position.x = 0;
                            this.particles.position.y = -1;
                        } else {
                            this.particles.position.x = 2.5;
                            this.particles.position.y = 0;
                        }
                    }
                    
                    if (shapeIndex !== this.currentShape) {
                        this.currentShape = shapeIndex;
                        this.morphToShape(this.currentShape);
                    }
                    
                    const rotationMultiplier = 0.5;
                    this.particles.rotation.y = scrollProgress * Math.PI * 2 * rotationMultiplier;
                    this.particles.rotation.x = scrollProgress * Math.PI * 0.3 * rotationMultiplier;
                    
                    ticking = false;
                };
                
                const requestTick = () => {
                    if (!ticking) {
                        requestAnimationFrame(updateOnScroll);
                        ticking = true;
                    }
                };
                
                window.addEventListener('scroll', requestTick);
                updateOnScroll();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updateMorph();
                
                this.particles.rotation.y += 0.001;
                
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        window.addEventListener('load', () => {
            new SpreadingParticles();
        });
    </script>
</body>
</html>
