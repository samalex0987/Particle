<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spreading Particles</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow-x: hidden;
            background: #000000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .section {
            height: 100vh;
            position: relative;
            z-index: 10;
        }
        
        .subsection {
            height: 100vh;
            position: relative;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10%;
        }
        
        .content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ffffff;
            z-index: 20;
        }
        
        .text-content {
            flex: 1;
            text-align: left;
            color: #ffffff;
            max-width: 40%;
        }
        
        .shape-content {
            flex: 1;
            height: 100%;
            position: relative;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .gradient-text {
            background: linear-gradient(135deg, #ffffff 0%, #cccccc 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #ffffff, #cccccc);
            z-index: 100;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="progress-bar" id="progress"></div>
    
    <div id="canvas-container"></div>
    
    <div class="section bg-transparent">
        <div class="content">
            <h1 class="text-6xl font-bold mb-6 gradient-text">Automate the mundane</h1>
            <p class="text-xl text-gray-400">Particles spreading like snow</p>
        </div>
    </div>
    
    <div class="section bg-transparent">
        <h1 class="text-6xl font-bold mb-6 gradient-text text-center">Our Solutions</h1>
        <div class="subsection">
            <div class="text-content">
                <h2 class="text-4xl font-bold mb-4 gradient-text">Data and AI</h2>
                <p class="text-lg text-gray-400">Harnessing data-driven insights with artificial intelligence.</p>
            </div>
            <div class="shape-content" data-shape="ai"></div>
        </div>
        <div class="subsection">
            <div class="text-content">
                <h2 class="text-4xl font-bold mb-4 gradient-text">Open Hybrid Cloud</h2>
                <p class="text-lg text-gray-400">Seamless integration across hybrid cloud environments.</p>
            </div>
            <div class="shape-content" data-shape="cloud"></div>
        </div>
        <div class="subsection">
            <div class="text-content">
                <h2 class="text-4xl font-bold mb-4 gradient-text">IT and Business Automation</h2>
                <p class="text-lg text-gray-400">Streamlining operations for efficiency and scale.</p>
            </div>
            <div class="shape-content" data-shape="tick"></div>
        </div>
        <div class="subsection">
            <div class="text-content">
                <h2 class="text-4xl font-bold mb-4 gradient-text">Security and Sustainability</h2>
                <p class="text-lg text-gray-400">Protecting systems while promoting sustainable practices.</p>
            </div>
            <div class="shape-content" data-shape="key"></div>
        </div>
    </div>

    <script>
        class SpreadingParticles {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.particleCount = 3000;
                this.currentShape = -1;
                this.targetPositions = new Float32Array(this.particleCount * 3);
                this.originalPositions = new Float32Array(this.particleCount * 3);
                this.morphProgress = 1; // Start with completed morph
                this.isTransitioning = false;
                
                this.init();
                this.createParticles();
                this.animate();
                this.setupScrollListener();
            }
            
            init() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setClearColor(0x000000, 0);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                this.camera.position.z = 6;
                
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const pointLight = new THREE.PointLight(0xffffff, 0.8);
                pointLight.position.set(10, 10, 10);
                this.scene.add(pointLight);
                
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            createParticles() {
                const geometry = new THREE.BufferGeometry();
                
                // Initialize with spread positions
                this.generateSpreadPositions(this.originalPositions);
                this.targetPositions.set(this.originalPositions);
                
                geometry.setAttribute('position', new THREE.BufferAttribute(this.originalPositions.slice(), 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.03,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.7,
                    vertexColors: true
                });
                
                const colors = new Float32Array(this.particleCount * 3);
                for (let i = 0; i < this.particleCount; i++) {
                    const color = new THREE.Color(0xffffff);
                    colors[i * 3] = color.r;
                    colors[i * 3 + 1] = color.g;
                    colors[i * 3 + 2] = color.b;
                }
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }
            
            generateSpreadPositions(positions) {
                for (let i = 0; i < this.particleCount; i++) {
                    const x = (Math.random() - 0.5) * 12;
                    const y = (Math.random() - 0.5) * 12;
                    const z = (Math.random() - 0.5) * 12;
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                }
            }
            
            // Generate "AI" text shape
            generateAIPositions(positions) {
                let particleIndex = 0;
                const letterSpacing = 1.5;
                const strokeWidth = 0.20;
                
                // Letter "A"
                const aPoints = [
                    // Left diagonal stroke
                    ...this.generateLinePoints(-1.5, -1, -0.5, 1, 300),
                    // Right diagonal stroke
                    ...this.generateLinePoints(-0.5, 1, 0.5, -1, 300),
                    // Horizontal bar
                    ...this.generateLinePoints(-1, 0, 0, 0, 200)
                ];
                
                // Letter "I"
                const iPoints = [
                    // Vertical stroke
                    ...this.generateLinePoints(1.5, -1, 1.5, 1, 400),
                    // Top horizontal
                    ...this.generateLinePoints(1.2, 1, 1.8, 1, 100),
                    // Bottom horizontal
                    ...this.generateLinePoints(1.2, -1, 1.8, -1, 100)
                ];
                
                const allPoints = [...aPoints, ...iPoints];
                
                // Fill positions array
                for (let i = 0; i < this.particleCount; i++) {
                    if (i < allPoints.length) {
                        positions[i * 3] = allPoints[i].x;
                        positions[i * 3 + 1] = allPoints[i].y;
                        positions[i * 3 + 2] = allPoints[i].z || 0;
                    } else {
                        // Random positions for remaining particles
                        positions[i * 3] = (Math.random() - 0.5) * 6;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
                    }
                }
            }
            
            generateLinePoints(x1, y1, x2, y2, count) {
                const points = [];
                for (let i = 0; i < count; i++) {
                    const t = i / count;
                    const x = x1 + (x2 - x1) * t + (Math.random() - 0.5) * 0.1;
                    const y = y1 + (y2 - y1) * t + (Math.random() - 0.5) * 0.1;
                    points.push({ x, y, z: (Math.random() - 0.5) * 0.3 });
                }
                return points;
            }
            
            // Generate cloud shape
            generateCloudPositions(positions) {
                for (let i = 0; i < this.particleCount; i++) {
                    // Create multiple spheres to form cloud shape
                    const cloudCenter = Math.floor(Math.random() * 5);
                    let centerX, centerY, radius;
                    
                    switch(cloudCenter) {
                        case 0: // Main body
                            centerX = 0;
                            centerY = 0;
                            radius = 1.2;
                            break;
                        case 1: // Left bump
                            centerX = -1;
                            centerY = 0.2;
                            radius = 0.8;
                            break;
                        case 2: // Right bump
                            centerX = 1;
                            centerY = 0.1;
                            radius = 0.9;
                            break;
                        case 3: // Top bump
                            centerX = -0.3;
                            centerY = 0.8;
                            radius = 0.7;
                            break;
                        case 4: // Small right bump
                            centerX = 0.7;
                            centerY = -0.3;
                            radius = 0.6;
                            break;
                    }
                    
                    // Generate point within sphere
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.random() * radius;
                    
                    positions[i * 3] = centerX + r * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = centerY + r * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = r * Math.cos(phi);
                }
            }
            
            // Generate checkmark/tick shape
            generateTickPositions(positions) {
                let particleIndex = 0;
                
                // First stroke (short diagonal up-left to down-right)
                const stroke1Points = this.generateLinePoints(-0.5, 0, 0, -0.8, 600);
                // Second stroke (from middle to up-right)
                const stroke2Points = this.generateLinePoints(0, -0.8, 1.2, 0.8, 800);
                
                const allPoints = [...stroke1Points, ...stroke2Points];
                
                for (let i = 0; i < this.particleCount; i++) {
                    if (i < allPoints.length) {
                        positions[i * 3] = allPoints[i].x;
                        positions[i * 3 + 1] = allPoints[i].y;
                        positions[i * 3 + 2] = allPoints[i].z || 0;
                    } else {
                        // Random positions around the tick
                        positions[i * 3] = (Math.random() - 0.5) * 4;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 1;
                    }
                }
            }
            
            // Generate key shape
            generateKeyPositions(positions) {
                let particleIndex = 0;
                
                // Key handle (circle)
                const handlePoints = [];
                for (let i = 0; i < 800; i++) {
                    const angle = (i / 800) * Math.PI * 2;
                    const radius = 0.6;
                    const x = -1.5 + radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    handlePoints.push({ x, y, z: (Math.random() - 0.5) * 0.2 });
                }
                
                // Key shaft (horizontal line)
                const shaftPoints = this.generateLinePoints(-0.9, 0, 1.2, 0, 500);
                
                // Key teeth
                const teeth1Points = this.generateLinePoints(0.8, 0, 0.8, -0.4, 100);
                const teeth2Points = this.generateLinePoints(1.0, 0, 1.0, -0.3, 100);
                const teeth3Points = this.generateLinePoints(1.2, 0, 1.2, -0.5, 100);
                
                const allPoints = [...handlePoints, ...shaftPoints, ...teeth1Points, ...teeth2Points, ...teeth3Points];
                
                for (let i = 0; i < this.particleCount; i++) {
                    if (i < allPoints.length) {
                        positions[i * 3] = allPoints[i].x;
                        positions[i * 3 + 1] = allPoints[i].y;
                        positions[i * 3 + 2] = allPoints[i].z || 0;
                    } else {
                        // Random positions around the key
                        positions[i * 3] = (Math.random() - 0.5) * 6;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 4;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 1;
                    }
                }
            }
            
            morphToShape(shapeIndex) {
                if (this.isTransitioning) return;
                
                this.isTransitioning = true;
                
                // Store current positions as starting point
                const currentPositions = this.particles.geometry.attributes.position.array;
                this.originalPositions.set(currentPositions);
                
                const newPositions = new Float32Array(this.particleCount * 3);
                
                switch(shapeIndex) {
                    case -1:
                        this.generateSpreadPositions(newPositions);
                        break;
                    case 0:
                        this.generateAIPositions(newPositions);
                        break;
                    case 1:
                        this.generateCloudPositions(newPositions);
                        break;
                    case 2:
                        this.generateTickPositions(newPositions);
                        break;
                    case 3:
                        this.generateKeyPositions(newPositions);
                        break;
                }
                
                this.targetPositions.set(newPositions);
                this.morphProgress = 0;
            }
            
            updateMorph() {
                if (this.morphProgress >= 1) {
                    this.isTransitioning = false;
                    return;
                }
                
                const positions = this.particles.geometry.attributes.position.array;
                
                for (let i = 0; i < this.particleCount * 3; i++) {
                    const start = this.originalPositions[i];
                    const target = this.targetPositions[i];
                    const progress = this.easeInOutQuad(this.morphProgress);
                    positions[i] = start + (target - start) * progress;
                }
                
                this.particles.geometry.attributes.position.needsUpdate = true;
                this.morphProgress += 0.02; // Slightly faster transition
            }
            
            easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }
            
            setupScrollListener() {
                let ticking = false;
                
                const updateOnScroll = () => {
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
                    const scrollProgress = scrollTop / scrollHeight;
                    
                    document.getElementById('progress').style.width = (scrollProgress * 100) + '%';
                    
                    const totalSections = 5; // 1 hero + 4 subsections
                    const sectionHeight = window.innerHeight;
                    const totalScrollableHeight = totalSections * sectionHeight;
                    
                    let shapeIndex = -1;
                    
                    if (scrollTop < sectionHeight) {
                        // First section - snow spread
                        shapeIndex = -1;
                        this.particles.position.x = 0;
                        this.particles.position.y = 0;
                    } else {
                        // Second section with 4 subsections
                        const subsectionIndex = Math.floor((scrollTop - sectionHeight) / sectionHeight);
                        shapeIndex = Math.min(subsectionIndex, 3); // Clamp to 0-3
                        
                        // Position particles on the right side for shapes
                        this.particles.position.x = 2.5;
                        this.particles.position.y = 0;
                    }
                    
                    if (shapeIndex !== this.currentShape) {
                        this.currentShape = shapeIndex;
                        this.morphToShape(this.currentShape);
                    }
                    
                    // Smoother rotation based on scroll
                    const rotationMultiplier = 0.5;
                    this.particles.rotation.y = scrollProgress * Math.PI * 2 * rotationMultiplier;
                    this.particles.rotation.x = scrollProgress * Math.PI * 0.3 * rotationMultiplier;
                    
                    ticking = false;
                };
                
                const requestTick = () => {
                    if (!ticking) {
                        requestAnimationFrame(updateOnScroll);
                        ticking = true;
                    }
                };
                
                window.addEventListener('scroll', requestTick);
                
                // Initial call to set up the first shape
                updateOnScroll();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updateMorph();
                
                // Gentle continuous rotation
                this.particles.rotation.y += 0.001;
                
                this.renderer.render(this.scene, this.camera);
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        
        window.addEventListener('load', () => {
            new SpreadingParticles();
        });
    </script>
</body>
</html>